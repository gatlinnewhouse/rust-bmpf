//! Generate Ziggurat lookup tables
//!
//! This program generates the pre-computed tables used by the Ziggurat algorithm
//! for normal and exponential distributions.

use std::fs::File;
use std::io::Write;

const ZIGGURAT_TABLE_SIZE: usize = 256;

// Normal distribution constants
const ZIGGURAT_NOR_R: f64 = 3.6541528853610088;
const NOR_SECTION_AREA: f64 = 0.00492867323399;
const NMANTISSA: f64 = 2147483648.0; // 31 bit mantissa

// Exponential distribution constants
const ZIGGURAT_EXP_R: f64 = 7.69711747013104972;
const EXP_SECTION_AREA: f64 = 0.0039496598225815571993;
const EMANTISSA: f64 = 4294967296.0; // 32 bit mantissa

fn create_normal_tables() -> ([u32; 256], [f64; 256], [f64; 256]) {
    let mut k = [0u32; 256];
    let mut w = [0.0f64; 256];
    let mut f = [0.0f64; 256];

    let mut x1 = ZIGGURAT_NOR_R;
    w[255] = x1 / NMANTISSA;
    f[255] = (-0.5 * x1 * x1).exp();

    // Index zero is special for tail strip
    k[0] = ((x1 * f[255] / NOR_SECTION_AREA * NMANTISSA).floor()) as u32;
    w[0] = NOR_SECTION_AREA / f[255] / NMANTISSA;
    f[0] = 1.0;

    for i in (1..255).rev() {
        // New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1}))
        // For normal: f(x) = exp(-0.5*x*x), so x = sqrt(-2*ln(y))
        let x = (-2.0 * (NOR_SECTION_AREA / x1 + f[i + 1]).ln()).sqrt();
        k[i + 1] = (x / x1 * NMANTISSA).floor() as u32;
        w[i] = x / NMANTISSA;
        f[i] = (-0.5 * x * x).exp();
        x1 = x;
    }

    k[1] = 0;

    (k, w, f)
}

fn create_exponential_tables() -> ([u32; 256], [f64; 256], [f64; 256]) {
    let mut k = [0u32; 256];
    let mut w = [0.0f64; 256];
    let mut f = [0.0f64; 256];

    let mut x1 = ZIGGURAT_EXP_R;
    w[255] = x1 / EMANTISSA;
    f[255] = (-x1).exp();

    // Index zero is special for tail strip
    k[0] = ((x1 * f[255] / EXP_SECTION_AREA * EMANTISSA).floor()) as u32;
    w[0] = EXP_SECTION_AREA / f[255] / EMANTISSA;
    f[0] = 1.0;

    for i in (1..255).rev() {
        // New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1}))
        // For exponential: f(x) = exp(-x), so x = -ln(y)
        let x = -(EXP_SECTION_AREA / x1 + f[i + 1]).ln();
        k[i + 1] = (x / x1 * EMANTISSA).floor() as u32;
        w[i] = x / EMANTISSA;
        f[i] = (-x).exp();
        x1 = x;
    }

    k[1] = 0;

    (k, w, f)
}

fn write_table(
    file: &mut File,
    name: &str,
    data: &[impl std::fmt::Display],
) -> std::io::Result<()> {
    writeln!(
        file,
        "pub const {}: [{}; {}] = [",
        name,
        if name.ends_with("_K") { "u32" } else { "f64" },
        data.len()
    )?;

    for (i, val) in data.iter().enumerate() {
        writeln!(file, "    {:.32},", val)?;
    }

    writeln!(file, "];\n")?;
    Ok(())
}

fn main() -> std::io::Result<()> {
    println!("Generating Ziggurat tables...");

    let (normal_k, normal_w, normal_f) = create_normal_tables();
    let (exp_k, exp_w, exp_f) = create_exponential_tables();

    let mut file = File::create("src/tables.rs")?;

    writeln!(
        file,
        "//! Pre-computed lookup tables for Ziggurat algorithm"
    )?;
    writeln!(file, "//! ")?;
    writeln!(file, "//! AUTOGENERATED - DO NOT EDIT")?;
    writeln!(file)?;

    write_table(&mut file, "NORMAL_K", &normal_k)?;
    write_table(&mut file, "NORMAL_W", &normal_w)?;
    write_table(&mut file, "NORMAL_F", &normal_f)?;

    write_table(&mut file, "EXPONENTIAL_K", &exp_k)?;
    write_table(&mut file, "EXPONENTIAL_W", &exp_w)?;
    write_table(&mut file, "EXPONENTIAL_F", &exp_f)?;

    println!("Tables generated successfully in src/tables.rs");

    Ok(())
}
