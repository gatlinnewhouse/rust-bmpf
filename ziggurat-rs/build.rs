//! Generate Ziggurat lookup tables
//!
//! This program generates the pre-computed tables used by the Ziggurat algorithm
//! for normal and exponential distributions.

use std::fs::File;
use std::io::Write;

// Size of Ziggurat tables
const ZIGGURAT_TABLE_SIZE: usize = 256;

// Normal distribution constants
const ZIGGURAT_NOR_R: f64 = 3.654_152_885_361_008_8;
const NOR_SECTION_AREA: f64 = 0.004_928_673_233_99;
const NMANTISSA: f64 = 2_147_483_648.0; // 31 bit mantissa

// Exponential distribution constants
const ZIGGURAT_EXP_R: f64 = 7.697_117_470_131_049_72;
const EXP_SECTION_AREA: f64 = 0.003_949_659_822_581_557_199_3;
const EMANTISSA: f64 = 4_294_967_296.0; // 32 bit mantissa

// Polynomial distribution constants
#[cfg(feature = "polynomial")]
pub const PN: f64 = 50.0;
#[cfg(feature = "polynomial")]
pub const ZIGGURAT_POL_SECTION_AREA: f64 = 7.927_791_049_125_3e-05;

fn create_normal_tables() -> (
    [u32; ZIGGURAT_TABLE_SIZE],
    [f64; ZIGGURAT_TABLE_SIZE],
    [f64; ZIGGURAT_TABLE_SIZE],
) {
    let mut k = [0u32; ZIGGURAT_TABLE_SIZE];
    let mut w = [0.0f64; ZIGGURAT_TABLE_SIZE];
    let mut f = [0.0f64; ZIGGURAT_TABLE_SIZE];

    let mut x1 = ZIGGURAT_NOR_R;
    w[255] = x1 / NMANTISSA;
    f[255] = (-0.5 * x1 * x1).exp();

    // Index zero is special for tail strip
    k[0] = ((x1 * f[255] / NOR_SECTION_AREA * NMANTISSA).floor()) as u32;
    w[0] = NOR_SECTION_AREA / f[255] / NMANTISSA;
    f[0] = 1.0;

    for i in (1..255).rev() {
        // New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1}))
        // For normal: f(x) = exp(-0.5*x*x), so x = sqrt(-2*ln(y))
        let x = (-2.0 * (NOR_SECTION_AREA / x1 + f[i + 1]).ln()).sqrt();
        k[i + 1] = (x / x1 * NMANTISSA).floor() as u32;
        w[i] = x / NMANTISSA;
        f[i] = (-0.5 * x * x).exp();
        x1 = x;
    }

    k[1] = 0;

    (k, w, f)
}

#[cfg(feature = "polynomial")]
fn polynomail_advance(x0: f64) -> f64 {
    let mut dx = 0.5;
    let mut x = x0;
    loop {
        let x1 = x + dx;
        let a = x1 * ((-PN * x0).exp() - (-PN * x1));
        if x1 == x {
            return x;
        }
        if a <= ZIGGURAT_POL_SECTION_AREA {
            x = x1;
        }
        dx *= 0.5;
    }
}

#[cfg(feature = "polynomial")]
fn crate_polynomial_tables() -> (
    [f64; ZIGGURAT_TABLE_SIZE],
    [f64; ZIGGURAT_TABLE_SIZE],
    [f64; ZIGGURAT_TABLE_SIZE],
) {
    let mut kp = [0.0f64; ZIGGURAT_TABLE_SIZE];
    let mut wp = [0.0f64; ZIGGURAT_TABLE_SIZE];
    let mut fp = [0.0f64; ZIGGURAT_TABLE_SIZE];

    let mut x1 = 0.0f64;
    for i in 0..255 {
        let x = polynomail_advance(x1);
        kp[i] = 1.0f64 - (-x1).exp();
        wp[i] = x;
        fp[i] = (-PN * x).exp();
        x1 = x;
    }
    kp[255] = 1.0f64 - (-1.0f64).exp();
    wp[255] = 1.0f64;
    fp[255] = 0.0f64;

    (kp, wp, fp)
}

fn create_exponential_tables() -> (
    [u32; ZIGGURAT_TABLE_SIZE],
    [f64; ZIGGURAT_TABLE_SIZE],
    [f64; ZIGGURAT_TABLE_SIZE],
) {
    let mut k = [0u32; ZIGGURAT_TABLE_SIZE];
    let mut w = [0.0f64; ZIGGURAT_TABLE_SIZE];
    let mut f = [0.0f64; ZIGGURAT_TABLE_SIZE];

    let mut x1 = ZIGGURAT_EXP_R;
    w[255] = x1 / EMANTISSA;
    f[255] = (-x1).exp();

    // Index zero is special for tail strip
    k[0] = ((x1 * f[255] / EXP_SECTION_AREA * EMANTISSA).floor()) as u32;
    w[0] = EXP_SECTION_AREA / f[255] / EMANTISSA;
    f[0] = 1.0;

    for i in (1..255).rev() {
        // New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1}))
        // For exponential: f(x) = exp(-x), so x = -ln(y)
        let x = -(EXP_SECTION_AREA / x1 + f[i + 1]).ln();
        k[i + 1] = (x / x1 * EMANTISSA).floor() as u32;
        w[i] = x / EMANTISSA;
        f[i] = (-x).exp();
        x1 = x;
    }

    k[1] = 0;

    (k, w, f)
}

fn write_table(
    file: &mut File,
    name: &str,
    data: &[impl std::fmt::Display],
) -> std::io::Result<()> {
    writeln!(
        file,
        "pub const {}: [{}; {}] = [",
        name,
        if name.ends_with("_K") && !name.contains("POLY") {
            "u32"
        } else {
            "f64"
        },
        data.len()
    )?;

    for val in data.iter() {
        writeln!(file, "    {:.18},", val)?;
    }

    writeln!(file, "];\n")?;
    Ok(())
}

fn write_file(path: &str) -> std::io::Result<File> {
    let mut file = File::create(path)?;
    writeln!(
        file,
        "//! Pre-computed lookup tables for Ziggurat algorithm"
    )?;
    writeln!(file, "//! ")?;
    writeln!(file, "//! AUTOGENERATED - DO NOT EDIT")?;
    writeln!(file)?;
    Ok(file)
}

fn main() -> std::io::Result<()> {
    println!("Generating Ziggurat tables...");

    {
        let (normal_k, normal_w, normal_f) = create_normal_tables();
        let mut norm_file = write_file("src/tables/normal.rs")?;
        write_table(&mut norm_file, "NORMAL_K", &normal_k)?;
        write_table(&mut norm_file, "NORMAL_W", &normal_w)?;
        write_table(&mut norm_file, "NORMAL_F", &normal_f)?;
    }

    {
        let (exp_k, exp_w, exp_f) = create_exponential_tables();
        let mut exp_file = write_file("src/tables/exponential.rs")?;
        write_table(&mut exp_file, "EXPONENTIAL_K", &exp_k)?;
        write_table(&mut exp_file, "EXPONENTIAL_W", &exp_w)?;
        write_table(&mut exp_file, "EXPONENTIAL_F", &exp_f)?;
    }

    #[cfg(feature = "polynomial")]
    {
        let (poly_k, poly_w, poly_f) = crate_polynomial_tables();
        let mut poly_file = write_file("src/tables/polynomial.rs")?;
        write_table(&mut poly_file, "POLY_K", &poly_k)?;
        write_table(&mut poly_file, "POLY_W", &poly_w)?;
        write_table(&mut poly_file, "POLY_F", &poly_f)?;
    }

    println!("Tables generated successfully in src/tables.rs");

    Ok(())
}
